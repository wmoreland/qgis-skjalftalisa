# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QgisSkjalftalisaDockWidget
                                 A QGIS plugin
 Interface for Veðurstofan earthquake data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-12-19
        git sha              : $Format:%H$
        copyright            : (C) 2024 by William M. Moreland
        email                : william@moreland.is
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import json
import logging
import requests
import geopandas as gpd

from datetime import datetime

from shapely.ops import orient
from shapely.geometry import shape, mapping

from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtGui import QColor
from qgis.PyQt.QtCore import pyqtSignal, QDateTime, Qt, QVariant
from qgis.core import (
    QgsVectorLayer,
    QgsProject,
    QgsSymbol,
    QgsFillSymbol,
    QgsGraduatedSymbolRenderer,
    QgsRendererRange,
    QgsProperty,
    QgsField,
    QgsFeatureRequest,
)

# Constants and configuratoins
BASE_API_URL = "https://vi-api.vedur.is/skjalftalisa/v1"
AREA_API_ENDPOINT = f"{BASE_API_URL}/areas"
EARTHQUAKE_API_ENDPOINT = f"{BASE_API_URL}/quakefilter"

DEFAULT_MAGNITUDE = (0, 7)
DEFAULT_DEPTH = (0, 25)

# Get the root logger
logger = logging.getLogger()

# Clear any existing handlers to prevent duplication
if logger.hasHandlers():
    logger.handlers.clear()

# Set up logging
logging_format = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
logging.basicConfig(
    level=logging.ERROR,
    filename="qgis_skjalftalisa.log",
    filemode="w",
    format=logging_format,
)

# Create and add a console handler
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.ERROR)
formatter = logging.Formatter(logging_format)
console_handler.setFormatter(formatter)

logger.addHandler(console_handler)


def log_error(message: str) -> None:
    logger = logging.getLogger(__name__)
    logger.error(message)

FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__),
                 "qgis_skjalftalisa_dockwidget_base.ui")
)

class InputValidationError(Exception):
    """Raised when user input is invalid."""
    pass

class ApiRequestError(Exception):
    """Riased when the API request fails."""
    pass

class GeoJsonProcessingError(Exception):
    """Raised when processing GeoJSON data fails."""
    pass

class QgisSkjalftalisaDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, iface, parent=None):
        """Constructor."""
        super(QgisSkjalftalisaDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # Set flag for time range adjustments
        self.updating_time_range = False

        # Store the iface object
        self.iface = iface

        # Populate the timeComboBox
        self.timeComboBox.addItems(
            [
                "Choose period",
                "Last 1 hour",
                "Last 3 hours",
                "Last 6 hours",
                "Last 12 hours",
                "Last 24 hours",
                "Last 2 days",
                "Last 7 days",
                "Last 14 days",
                "Last 30 days",
                "Last 60 days",
                "Last 90 days",
                "Last 365 days",
            ]
        )
        # set the placeholder as default
        self.timeComboBox.setCurrentIndex(0)
        self.timeComboBox.currentIndexChanged.connect(self.update_time_range)

        # Set initial values for dateUntilTimeEdit and dateFromTimeEdit
        self.update_time_range()

        # Connect date/time edits to a custom range handler
        self.dateFromTimeEdit.dateTimeChanged.connect(
            self.handle_custom_date_change)
        self.dateUntilTimeEdit.dateTimeChanged.connect(
            self.handle_custom_date_change)

        # Initialize variables
        self.earthquake_layer = None  # earthquake points
        self.area_layer = None  # filter-by-area polygon

        # Initialize areaComboBox
        self.populate_area_combobox()

        # Connect buttons to methods
        self.filterPushButton.clicked.connect(self.fetch_and_load_earthquakes)
        self.resetPushButton.clicked.connect(self.reset_values)

        # Initialize areaCheckBox (optional logic)
        self.areaCheckBox.stateChanged.connect(self.handle_area_checkbox)
    
    def show_error(self, message: str, title: str = "Error") -> None:
        """Display an error message in a QMessageBox.

        Args:
            message (str): The error message to display.
            title (str): The title of the message box (default: "Error")
        """
        QtWidgets.QMessageBox.critical(self, "Error", message)

    def fetch_and_load_earthquakes(self) -> None:
        """Fetch earthquake data and load it into QGIS."""
        try:
            self._validate_time_range()
            payload = self._construct_earthquake_payload()
            response = self._fetch_earthquake_data(payload)
            geojson_data = self._process_earthquake_response(response)

            if geojson_data is None:
                return  # Exit early if there are no earthquakes

            self._save_and_load_geojson(geojson_data, "Earthquakes")
            self._display_area_if_checked()

        except InputValidationError:
            pass  # Already displayed to the user
        except ApiRequestError as e:
            log_error(f"API error: {str(e)}")
            self.show_error(f"Could not retrieve data from the earthquake API:"
                            f" {str(e)}")
        except GeoJsonProcessingError as e:
            log_error(f"GeoJSON processing error: {str(e)}")
            self.show_error(f"Error processing earthquake data: {str(e)}")
        except Exception as e:
            log_error(f"Unexpected error: {str(e)}")
            self.show_error(f"An unexpected error occurred: {str(e)}")
        
    def _validate_time_range(self) -> None:
        start_time = self.dateFromTimeEdit.dateTime()
        end_time = self.dateUntilTimeEdit.dateTime()

        if start_time >= end_time:
            raise ValueError("'From' time must be earlier than 'Until' time.")
    
    def _get_selected_area_polygon(self, selected_area: str) -> list:
        """Retrieve the polygon geometry of the selected area.

        Args:
            selected_area (str): The name of the selected area.

        Returns:
            list: The coordinates of the polygon if found, otherwise None.
        """
        try:
            # Locate the geometry of the selected area in the GeoDataFrame
            area_geometry = self.feature_collection_gdf.loc[
                self.feature_collection_gdf["name"] == selected_area, "geometry"
            ]

            if area_geometry.empty:
                raise ValueError(f"No geometry found for the selected area:"
                                 f" {selected_area}")

            # Extract the coordinates from the geometry
            polygon_coordinates = area_geometry.iloc[0].exterior.coords[:]

            # Return as a list of [longitude, latitude] pairs
            # return [[coord[0], coord[1]] for coord in polygon_coordinates]

            # Return as a list of [latitude, longitude] pairs
            return [[coord[1], coord[0]] for coord in polygon_coordinates]
        
        except Exception as e:
            raise ValueError(f"Error retrieving polygon for area"
                             f" '{selected_area}': {str(e)}")
    
    def _construct_earthquake_payload(self) -> dict:
        """Construct the payload for the earthquake API request.

        Returns:
            dict: A dictionary of keys and values as specified on Vedurstofan's
            API website.
        """

        try:
            start_time = start_time = self.dateFromTimeEdit.dateTime().toString("yyyy-MM-dd HH:mm:ss")
            end_time = self.dateUntilTimeEdit.dateTime().toString("yyyy-MM-dd HH:mm:ss")
            size_min = self.magMinSpinBox.value()
            size_max = self.magMaxSpinBox.value()
            depth_min = self.depthMinSpinBox.value()
            depth_max = self.depthMaxSpinBox.value()

            payload = {
            "depth_max": depth_max,
            "depth_min": depth_min,
            "end_time": end_time,
            "event_type": ["qu"],
            "magnitude_preference": ["Mlw"],
            "originating_system": ["SIL picks"],
            "size_max": size_max,
            "size_min": size_min,
            "start_time": start_time,
            }

            # Include selected area if specified
            selected_area = self.areaComboBox.currentText()
            if selected_area != "Choose area":
                area_polygon = self._get_selected_area_polygon(selected_area)
                if area_polygon:
                    payload["area"] = area_polygon

            return payload
        except Exception as e:
            raise ValueError(f"Failed to construct earthquake payload: {str(e)}")

    def _fetch_earthquake_data(self, payload: dict) -> requests.Response:
        """Send a POST request to fetch earthquake data

        Args:
            payload (dict): A dictionary of keys and values as specified on
            Vedurstofan's API website.

        Returns:
            requests.Response: a POST response containing JSON earthquake data
        """
        try:
            response = requests.post(EARTHQUAKE_API_ENDPOINT, json=payload)
            response.raise_for_status()  # Raises an HTTPError for bad responses
            return response
        except requests.RequestException as e:
            raise requests.RequestException(f"HTTP request failed: {str(e)}")
    
    def _process_earthquake_response(self, response: requests.Response) -> dict:
        """Process the API response into a correctly formatted GeoJSON and
        return it.

        Args:
            response (requests.Response): a POST response containing JSON
            earthquake data

        Returns:
            dict: dictionary of GeoJSON-like keys and values
        """
        try:
            quake_data = response.json()
            # check if the response contains no features
            if not quake_data:
                QtWidgets.QMessageBox.information(
                    self,
                    "No Earthquakes Found",
                    "No earthquakes were found with the selected criteria."
                )
                return None
            
            return {
                "type": "FeatureCollection",
                "features": quake_data,
            }
        except json.JSONDecodeError as e:
            raise ValueError(f"Failed to parse API response as JSON: {str(e)}")
        except KeyError as e:
            raise ValueError(f"Unexpected API response format: Missing key"
                             f" {str(e)}")
    
    def _save_and_load_geojson(self,
                               geojson_data: dict,
                               layer_name: str) -> None:
        """Save GeoJSON to a temporary file and load it into QGIS.

        Args:
            geojson_data (dict): dictionary of GeoJSON-like keys and values
            layer_name (str): layer name
        """
        try:
            from tempfile import NamedTemporaryFile

            with NamedTemporaryFile(suffix=".geojson",
                                    delete=False) as temp_file:
                geojson_path = temp_file.name
                with open(geojson_path, "w") as file:
                    json.dump(geojson_data, file, indent=2)

            # Load the GeoJSON layer into QGIS
            self.load_geojson_layer(geojson_path, layer_name)
        except (OSError, IOError) as e:
            raise IOError(f"Failed to save or load GeoJSON data: {str(e)}")
    
    def _display_area_if_checked(self) -> None:
        """Display a polygon of the area of interest if the checkbox is ticked.
        """
        try:
            if self.areaCheckBox.isChecked():
                selected_area = self.areaComboBox.currentText()
                if selected_area != "Choose area":
                    geometry_str = self.feature_collection_gdf.loc[
                        self.feature_collection_gdf["name"] == selected_area
                    ]["geometry"].to_json()
                    self.display_area_polygon(selected_area, geometry_str)
        except KeyError:
            raise ValueError(f"Failed to find geometry for area:"
                             f" {selected_area}")


    def load_geojson_layer(self, geojson_path, layer_name="Earthquakes"):
        """Load a GeoJSON file as a temporary layer in QGIS, including the date
        range in the name."""
        # Read the GeoJSON file to check for features
        with open(geojson_path, "r") as file:
            geojson_data = json.load(file)

        # Check if there are features in the GeoJSON
        if not geojson_data.get("features"):
            QtWidgets.QMessageBox.information(
                self,
                "No Earthquakes Found",
                "No earthquakes were found with the current settings.",
            )
            return

        # Safely check and remove the layer
        try:
            if self.earthquake_layer:
                QgsProject.instance().removeMapLayer(self.earthquake_layer.id())
        except RuntimeError:
            # Layer was already deleted, so just clear the reference
            pass

        # Get the date range from the widgets
        start_date = self.dateFromTimeEdit.date().toString("yyyy-MM-dd")
        end_date = self.dateUntilTimeEdit.date().toString("yyyy-MM-dd")

        # Load the GeoJSON file as a vector layer
        layer_name = f"{layer_name} {start_date} to {end_date}"
        layer = QgsVectorLayer(geojson_path, layer_name, "ogr")
        if layer.isValid():
            # self.apply_simple_earthquake_symbology(layer)
            self.apply_graduated_earthquake_symbology(layer)
            QgsProject.instance().addMapLayer(layer)
            self.earthquake_layer = layer  # Save the layer reference
        else:
            self.show_error("Failed to load earthquakes layer.")

    def reset_values(self):
        """Reset all values in the widgets and remove the created layer."""
        # Remove "Custom range" from the combo box if it exists
        custom_range_index = self.timeComboBox.findText("Custom range")
        if custom_range_index != -1:
            self.timeComboBox.removeItem(custom_range_index)

        # Reset the timeComboBox to the default placeholder
        self.timeComboBox.setCurrentIndex(0)

        # Reset the areaComboBox to the default placeholder
        self.areaComboBox.setCurrentIndex(0)

        # Reset date/time edits
        self.update_time_range()  # Reset dateFromTimeEdit and dateUntilTimeEdit

        # Reset spin boxes to their default values
        self.magMinSpinBox.setValue(0)
        self.magMaxSpinBox.setValue(7)
        self.depthMinSpinBox.setValue(0)
        self.depthMaxSpinBox.setValue(25)

        # Safely check and remove the layer
        try:
            if self.earthquake_layer:
                QgsProject.instance().removeMapLayer(self.earthquake_layer.id())
        except RuntimeError:
            # Layer was already deleted, so just clear the reference
            pass

        # Safely remove the area polygon layer
        try:
            if self.area_layer:
                QgsProject.instance().removeMapLayer(self.area_layer.id())
        except RuntimeError:
            pass
        self.area_layer = None

        # Clear the layer reference
        self.earthquake_layer = None

        # Refresh the map canvas
        self.iface.mapCanvas().refresh()

    def apply_graduated_earthquake_symbology(self, layer):
        """Apply graduated symbology to the earthquake layer based on
        recency."""
        if not layer or not layer.isValid():
            return

        # Define the HTML template for map tips
        html_template = """
        <table border='1' style='border-collapse:collapse'>
        <tr>
            <td>Kerfi</td>
            <td>[% "originating_system" %]</td>
        </tr>
        <tr>
            <td>Dags</td>
            <td>[% format_date( "Time", 'yyyy-MM-dd HH:mm') %]</td>
        </tr>
        <tr>
            <td>Dýpi</td>
            <td>[% "depth" %]</td>
        </tr>
        <tr>
            <td>Stærðir</td>
            <td>[% "magnitude" %] [% "magnitude_type" %]</td>
        </tr>
        </table>
        """

        # Set the map tip template for the layer
        layer.setMapTipTemplate(html_template)

        # Fetch attribute table
        layer_data = [feat for feat in layer.getFeatures()]

        if not layer_data:
            self.show_error("No features in the layer to apply symbology.")
            return

        # Determine the time range and convert to numeric values
        time_field = "time"
        numeric_time_field = "__time_numeric"

        # Check if the field already exists, if not, add it
        if numeric_time_field not in [field.name() for field in layer.fields()]:
            layer.startEditing()
            layer.dataProvider().addAttributes(
                [QgsField(numeric_time_field, QVariant.Double)]
            )
            layer.updateFields()
            layer.commitChanges()

        # Populate the numeric time field
        layer.startEditing()
        for feat in layer.getFeatures():
            feat_time = (
                feat[time_field].toPyDateTime().timestamp()
                if isinstance(feat[time_field], QDateTime)
                else feat[time_field].timestamp()
            )
            feat[numeric_time_field] = feat_time
            layer.updateFeature(feat)
        layer.commitChanges()

        # Fetch the range of numeric time values
        time_values = [feat[numeric_time_field] for feat in layer.getFeatures()]
        min_time = min(time_values)
        max_time = max(time_values)

        # Create ranges based on recency
        total_seconds = max_time - min_time

        # datetime format for labels
        dt_fmt = '%Y-%m-%d %H:%M'
        
        # Handle case where all timestamps are the same
        if min_time == max_time:
            single_category_color = "#b32d1e3e"  # Fallback color
            label = (f"All events at"
                     f" {datetime.fromtimestamp(min_time).strftime(dt_fmt)}")
            symbol = QgsSymbol.defaultSymbol(layer.geometryType())
            if symbol:
                symbol.setColor(QColor(single_category_color))

                # Set size scaling using magnitude
                size_expression = ('scale_linear( "magnitude",'
                                'minimum("magnitude"),'
                                'maximum("magnitude"), 1, 10)')
                size_property = QgsProperty.fromExpression(size_expression)
                symbol.setDataDefinedSize(size_property)

                range_ = QgsRendererRange(min_time, max_time, symbol, label)

            renderer = QgsGraduatedSymbolRenderer(numeric_time_field, [range_])
            layer.setRenderer(renderer)
            layer.triggerRepaint()
            return

        num_classes = 5  # Number of color ranges
        step = total_seconds / num_classes

        ranges = []
        colors = [
            "#b3edd1cb",
            "#b3d499a7",
            "#b3aa688f",
            "#b36e4071",
            "#b32d1e3e",
        ]  # Gradient colors
        for i in range(num_classes):
            low_bound = min_time + i * step
            upp_bound = min_time + (i + 1) * step

            label_low = f"{datetime.fromtimestamp(low_bound).strftime(dt_fmt)}"
            label_upp = f"{datetime.fromtimestamp(upp_bound).strftime(dt_fmt)}"

            label = f"{label_low} - {label_upp}"
            symbol = QgsSymbol.defaultSymbol(layer.geometryType())
            if symbol:
                symbol.setColor(QColor(colors[i]))

                # Set size scaling using QgsProperty and scale_linear expression
                size_expression = ('scale_linear( "magnitude",'
                                   'minimum("magnitude"),'
                                   'maximum("magnitude"), 1, 10)')
                size_property = QgsProperty.fromExpression(size_expression)
                symbol.setDataDefinedSize(size_property)

                ranges.append(QgsRendererRange(
                    low_bound, upp_bound, symbol, label))

        # Apply graduated symbology
        renderer = QgsGraduatedSymbolRenderer(numeric_time_field, ranges)
        renderer.setMode(QgsGraduatedSymbolRenderer.EqualInterval)
        renderer.setOrderBy(
            QgsFeatureRequest.OrderBy(
                [QgsFeatureRequest.OrderByClause("__time_numeric", True)]
            )
        )
        renderer.setOrderByEnabled(True)
        layer.setRenderer(renderer)
        layer.triggerRepaint()

    def update_time_range(self):
        """Update the date/time range based on the timeComboBox selection."""
        self.updating_time_range = True  # Set the flag
        current_time = QDateTime.currentDateTime()
        selected_text = self.timeComboBox.currentText()

        # Default: Reset to current day
        start_time = current_time.addDays(-7)  # Default: 7 days
        end_time = current_time

        if selected_text == "Last 1 hour":
            start_time = current_time.addSecs(-3600)  # 1 hour
        elif selected_text == "Last 3 hours":
            start_time = current_time.addSecs(-3 * 3600)  # 3 hours
        elif selected_text == "Last 6 hours":
            start_time = current_time.addSecs(-6 * 3600)  # 6 hours
        elif selected_text == "Last 12 hours":
            start_time = current_time.addSecs(-12 * 3600)  # 12 hours
        elif selected_text == "Last 24 hours":
            start_time = current_time.addSecs(-24 * 3600)  # 24 hours
        elif selected_text == "Last 2 days":
            start_time = current_time.addDays(-2)  # 2 days
        elif selected_text == "Last 7 days":
            start_time = current_time.addDays(-7)  # 7 days
        elif selected_text == "Last 14 days":
            start_time = current_time.addDays(-14)  # 14 days
        elif selected_text == "Last 30 days":
            start_time = current_time.addDays(-30)  # 30 days
        elif selected_text == "Last 60 days":
            start_time = current_time.addDays(-60)  # 60 days
        elif selected_text == "Last 90 days":
            start_time = current_time.addDays(-90)  # 90 days
        elif selected_text == "Last 365 days":
            start_time = current_time.addDays(-365)  # 365 days
        else:
            start_time = current_time.addDays(-7)  # Default: 7 days

        # Round start_time and end_time to the nearest half-hour
        def round_to_nearest_half_hour(qdatetime):
            minute = qdatetime.time().minute()
            second = qdatetime.time().second()

            # Calculate difference to the nearest half-hour
            if minute < 15 or (minute == 15 and second == 0):
                adjustment = -(minute * 60 + second)
            elif minute < 45 or (minute == 45 and second == 0):
                adjustment = (30 - minute) * 60 - second
            else:
                adjustment = (60 - minute) * 60 - second

            return qdatetime.addSecs(adjustment)

        start_time = round_to_nearest_half_hour(start_time)
        end_time = round_to_nearest_half_hour(end_time)

        # Update the date/time widgets
        self.dateFromTimeEdit.setDateTime(start_time)
        self.dateUntilTimeEdit.setDateTime(end_time)

        self.updating_time_range = False  # Unset the flag

    def handle_custom_date_change(self):
        """Set the timeComboBox to 'Custom range' when date/time is manually
        changed."""
        if self.updating_time_range:
            return  # Skip if the date fields are being updated programmatically

        # Add "Custom range" if it doesn't exist
        custom_range_index = self.timeComboBox.findText("Custom range")
        if custom_range_index == -1:
            self.timeComboBox.addItem("Custom range")
            custom_range_index = self.timeComboBox.count() - 1

        # Set the combo box to "Custom range" unless it's already set
        if self.timeComboBox.currentText() != "Custom range":
            self.timeComboBox.setCurrentIndex(custom_range_index)

    def populate_area_combobox(self):
        """Fetch area information from the API and populate the areaComboBox."""
        url = "https://vi-api.vedur.is/skjalftalisa/v1/areas"
        headers = {"Accept": "application/json"}

        # Clear the combo box and prepare to store polygons
        self.areaComboBox.clear()
        self.areaComboBox.addItem("Choose area")  # Placeholder item

        try:
            # Fetch areas from the API
            response = requests.get(url, headers=headers)
            if response.status_code == 200:
                response = response.json()

                features = []

                for i in response:
                    id_area = i["id_area"]
                    area_json = i["area_json"]
                    area_name = area_json["name"]
                    area_polygon = [
                        list(coord_xy)
                        for coord_xy in [
                            (coord_yx[1], coord_yx[0])
                            for coord_yx in area_json["polygon"]
                        ]
                    ]
                    area_polygon.append(area_polygon[0])  # Ensure closure
                    area_polygon.reverse()

                    partial_geojson = {
                        "type": "Feature",
                        "properties": {
                            "name": area_name,
                            "id": id_area
                            },
                        "geometry": {
                            "type": "Polygon",
                            "coordinates": [area_polygon]
                            },
                    }

                    features.append(partial_geojson)

                feature_collection_str = json.dumps(
                    {"type": "FeatureCollection", "features": features}
                )

                feature_collection_geojson = json.loads(feature_collection_str)
                self.feature_collection_gdf = gpd.GeoDataFrame.from_features(
                    feature_collection_geojson["features"], crs="EPSG:4326"
                )

                self.feature_collection_gdf["ends_with_vi"] = (
                    self.feature_collection_gdf["name"].str.endswith("- VÍ")
                )
                self.feature_collection_gdf.sort_values(
                    by=["ends_with_vi", "name"],
                    ascending=[False, True],
                    inplace=True,
                    ignore_index=True,
                )
                self.feature_collection_gdf.drop(columns=["ends_with_vi"],
                                                 inplace=True)

                if not self.feature_collection_gdf.empty:
                    # Populate the combo box
                    for name in self.feature_collection_gdf["name"]:
                        self.areaComboBox.addItem(name)
                    # set placeholder as default
                    self.areaComboBox.setCurrentIndex(0)
                else:
                    self.show_error("No areas available.")
            else:
                self.show_error(
                    f"Failed to fetch areas:"
                    f" {response.status_code} - {response.text}"
                )
        except Exception as e:
            self.show_error(f"An error occurred while fetching areas: {str(e)}")

    def display_area_polygon(self, selected_area, geometry_str):
        """Display the selected area's polygon as a separate layer."""
        try:
            # Safely check and remove the layer
            try:
                if self.area_layer:
                    QgsProject.instance().removeMapLayer(self.area_layer.id())
            except RuntimeError:
                # Layer was already deleted, so just clear the reference
                pass

            # Parse the geometry string into a dictionary
            geojson = json.loads(geometry_str)

            # Extract the first feature's geometry from the FeatureCollection
            if geojson["type"] == "FeatureCollection" and "features" in geojson:
                feature_geometry = geojson["features"][0]["geometry"]
            else:
                raise ValueError(
                    "Invalid GeoJSON: Expected a FeatureCollection with"
                    " features."
                )

            # Convert the feature geometry to a shapely object
            geometry = shape(feature_geometry)

            # Ensure the geometry follows the right-hand rule
            oriented_geometry = orient(geometry, sign=1.0)

            # Convert the oriented geometry back to GeoJSON format
            geojson_oriented = mapping(oriented_geometry)

            # Wrap in FeatureCollection format
            geojson_data_corrected = {
                "type": "FeatureCollection",
                "features": [
                    {
                        "type": "Feature",
                        "geometry": geojson_oriented,
                        "properties": {"name": selected_area},
                    }
                ],
            }

            from tempfile import NamedTemporaryFile

            # Write the corrected GeoJSON to a temporary file
            with NamedTemporaryFile(suffix=".geojson",
                                    delete=False) as temp_file:
                geojson_path = temp_file.name
                with open(geojson_path, "w") as file:
                    json.dump(geojson_data_corrected, file, indent=2)

            # Load the corrected GeoJSON as a layer
            layer_name = f"Area: {selected_area}"
            layer = QgsVectorLayer(geojson_path, layer_name, "ogr")
            if layer.isValid():
                self.apply_area_symbology(layer)
                QgsProject.instance().addMapLayer(layer)
                self.area_layer = layer  # Save the reference to the layer
            else:
                self.show_error("Failed to load area polygon layer.")
        except Exception as e:
            self.show_error(f"An error occurred while displaying the polygon:"
                            f" {str(e)}")

    def apply_area_symbology(self, layer):
        """Applies a simple symbology to the area polygon

        Args:
            layer (qgis._core.QgsVectorLayer): polygon of area of interest
        """
        if not layer or not layer.isValid():
            return

        symbol = QgsFillSymbol.createSimple(
            {"color": "#330000FF", "outline_color": "#0000FF"}
        )

        layer.renderer().setSymbol(symbol)
        layer.triggerRepaint()

    def handle_area_checkbox(self, state):
        """Manages changes to the "Show area" checkbox

        Args:
            state (int): Set by Qt when the checkbox is ticked/unticked
        """
        if state == Qt.Checked:
            pass  # don't do anything - this is handled by earthquake function
        else:
            try:
                if self.area_layer:
                    QgsProject.instance().removeMapLayer(self.area_layer.id())
            except RuntimeError:
                pass
            self.area_layer = None

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
