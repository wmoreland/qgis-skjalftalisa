# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QgisSkjalftalisaDockWidget
                                 A QGIS plugin
 Interface for Ve√∞urstofan earthquake data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-12-19
        git sha              : $Format:%H$
        copyright            : (C) 2024 by William M. Moreland
        email                : william@moreland.is
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import math
import json
import requests
from datetime import datetime, timedelta

from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtGui import QColor
from qgis.PyQt.QtCore import pyqtSignal, QDateTime
from qgis.core import (
    QgsVectorLayer,
    QgsProject,
    QgsSymbol,
    QgsGraduatedSymbolRenderer,
    QgsRendererRange,
    QgsSymbolLayer,
    QgsProperty,
    QgsStyle,
    QgsSimpleMarkerSymbolLayer,
    QgsSingleSymbolRenderer
    )

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'qgis_skjalfalisa_dockwidget_base.ui'))


class QgisSkjalftalisaDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, iface, parent=None):
        """Constructor."""
        super(QgisSkjalftalisaDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # Store the iface object
        self.iface = iface

        # Populate the timeComboBox
        self.timeComboBox.addItems([
            "Choose period", 
            "Last 1 hour", 
            "Last 3 hours", 
            "Last 6 hours", 
            "Last 12 hours",
            "Last 24 hours", 
            "Last 2 days", 
            "Last 7 days", 
            "Last 14 days", 
            "Last 30 days", 
            "Last 60 days", 
            "Last 90 days", 
            "Last 365 days"
        ])
        self.timeComboBox.setCurrentIndex(0)  # Set the placeholder as the default
        self.timeComboBox.currentIndexChanged.connect(self.update_time_range)

        # Set initial values for dateUntilTimeEdit and dateFromTimeEdit
        self.update_time_range()

        # Initialize variables
        self.loaded_layer = None

        # Connect buttons to methods
        self.filterPushButton.clicked.connect(self.fetch_and_load_earthquakes)
        self.resetPushButton.clicked.connect(self.reset_values)

    def fetch_and_load_earthquakes(self):
        """Fetch earthquake data and load it into QGIS."""
        # Validate the date range
        start_time = self.dateFromTimeEdit.dateTime()
        end_time = self.dateUntilTimeEdit.dateTime()
        if start_time >= end_time:
            self.show_error("Invalid date range: 'From' time must be earlier than 'Until' time.")
            return

        # Convert to string for the API
        start_time_str = start_time.toString("yyyy-MM-dd HH:mm:ss")
        end_time_str = end_time.toString("yyyy-MM-dd HH:mm:ss")

        # Fetch other values
        size_min = self.magMinSpinBox.value()
        size_max = self.magMaxSpinBox.value()
        depth_min = self.depthMinSpinBox.value()
        depth_max = self.depthMaxSpinBox.value()

        # Construct the request body
        url = "https://vi-api.vedur.is/skjalftalisa/v1/quakefilter"
        headers = {"Content-Type": "application/json"}
        body = {
            "area": [
                [63.2, -24.6],
                [66.6, -24.6],
                [66.6, -13.4],
                [63.2, -13.4],
            ],
            "depth_max": depth_max,
            "depth_min": depth_min,
            "end_time": end_time_str,
            "event_type": ["qu"],
            "magnitude_preference": ["Mlw"],
            "originating_system": ["SIL picks"],
            "size_max": size_max,
            "size_min": size_min,
            "start_time": start_time_str,
        }

        try:
            # Send the POST request
            response = requests.post(url, headers=headers, json=body)

            if response.status_code == 200:
                quake_data = response.json()
                geojson_data = {
                    "type": "FeatureCollection",
                    "features": quake_data,
                }

                # Use a temporary file to save the GeoJSON
                from tempfile import NamedTemporaryFile
                with NamedTemporaryFile(suffix=".geojson", delete=False) as temp_file:
                    geojson_path = temp_file.name
                    with open(geojson_path, "w") as file:
                        json.dump(geojson_data, file, indent=2)

                # Load the GeoJSON as a temporary layer in QGIS
                self.load_geojson_layer(geojson_path, "Earthquakes")
            else:
                self.show_error(f"Error: {response.status_code} - {response.text}")
        except Exception as e:
            self.show_error(f"An error occurred: {str(e)}")



    def load_geojson_layer(self, geojson_path, layer_name="Earthquakes"):
        """Load a GeoJSON file as a temporary layer in QGIS, including the date range in the name."""
        # Read the GeoJSON file to check for features
        with open(geojson_path, "r") as file:
            geojson_data = json.load(file)
        
        # Check if there are features in the GeoJSON
        if not geojson_data.get("features"):
            QtWidgets.QMessageBox.information(self, "No Earthquakes Found", "No earthquakes were found with the current settings.")
            return
        
        # Safely check and remove the layer
        try:
            if self.loaded_layer:
                QgsProject.instance().removeMapLayer(self.loaded_layer.id())
        except RuntimeError:
            # Layer was already deleted, so just clear the reference
            pass

        # Get the date range from the widgets
        start_date = self.dateFromTimeEdit.date().toString("yyyy-MM-dd")
        end_date = self.dateUntilTimeEdit.date().toString("yyyy-MM-dd")

        # Construct the new layer name
        layer_name_with_date = f"{layer_name} {start_date} to {end_date}"

        # Load the GeoJSON file as a vector layer
        layer = QgsVectorLayer(geojson_path, layer_name_with_date, "ogr")
        if not layer.isValid():
            self.show_error("Failed to load GeoJSON layer.")
            return

        # Apply simple symbology
        self.apply_simple_earthquake_symbology(layer)

        # Add the layer to the QGIS project
        QgsProject.instance().addMapLayer(layer)

        # Save the layer reference
        self.loaded_layer = layer


    
    def reset_values(self):
        """Reset all values in the widgets and remove the created layer."""
        # Reset date/time edits by calling update_time_range
        self.timeComboBox.setCurrentIndex(0)  # Reset the combo box to the default placeholder
        self.update_time_range()  # Reset dateFromTimeEdit and dateUntilTimeEdit

        # Reset spin boxes to their default values
        self.magMinSpinBox.setValue(-3)
        self.magMaxSpinBox.setValue(7)
        self.depthMinSpinBox.setValue(0)
        self.depthMaxSpinBox.setValue(80)

        # Safely check and remove the layer
        try:
            if self.loaded_layer:
                QgsProject.instance().removeMapLayer(self.loaded_layer.id())
        except RuntimeError:
            # Layer was already deleted, so just clear the reference
            pass

        # Clear the layer reference
        self.loaded_layer = None

        # Refresh the map canvas
        self.iface.mapCanvas().refresh()



    def apply_simple_earthquake_symbology(self, layer):
        """Apply a simple circle symbology to the earthquake layer."""
        if not layer or not layer.isValid():
            return

        # Create a basic symbol with a circle
        symbol = QgsSymbol.defaultSymbol(layer.geometryType())
        if symbol is not None:
            marker_layer = QgsSimpleMarkerSymbolLayer()
            marker_layer.setColor(QColor("#d73027"))  # Set a default red color
            marker_layer.setSize(4.0)  # Default size in mm
            symbol.changeSymbolLayer(0, marker_layer)

        # Apply a single symbol renderer
        renderer = QgsSingleSymbolRenderer(symbol)
        layer.setRenderer(renderer)
        layer.triggerRepaint()


    def show_error(self, message):
        """Show an error message to the user."""
        QtWidgets.QMessageBox.critical(self, "Error", message)
    
    def update_time_range(self):
        """Update the date/time range based on the timeComboBox selection."""
        current_time = QDateTime.currentDateTime()
        selected_text = self.timeComboBox.currentText()

        # Default: Reset to current day
        start_time = current_time
        end_time = current_time

        if selected_text == "Last 1 hour":
            start_time = current_time.addSecs(-3600)  # 1 hour
        elif selected_text == "Last 3 hours":
            start_time = current_time.addSecs(-3 * 3600)  # 3 hours
        elif selected_text == "Last 6 hours":
            start_time = current_time.addSecs(-6 * 3600)  # 6 hours
        elif selected_text == "Last 12 hours":
            start_time = current_time.addSecs(-12 * 3600)  # 12 hours
        elif selected_text == "Last 24 hours":
            start_time = current_time.addSecs(-24 * 3600)  # 24 hours
        elif selected_text == "Last 2 days":
            start_time = current_time.addDays(-2)  # 2 days
        elif selected_text == "Last 7 days":
            start_time = current_time.addDays(-7)  # 7 days
        elif selected_text == "Last 14 days":
            start_time = current_time.addDays(-14)  # 14 days
        elif selected_text == "Last 30 days":
            start_time = current_time.addDays(-30)  # 30 days
        elif selected_text == "Last 60 days":
            start_time = current_time.addDays(-60)  # 60 days
        elif selected_text == "Last 90 days":
            start_time = current_time.addDays(-90)  # 90 days
        elif selected_text == "Last 365 days":
            start_time = current_time.addDays(-365)  # 365 days
        else:
            start_time = current_time.addDays(-7)  # 7 days

        # Round end time to the last half-hour
        end_time = end_time.addSecs(-(end_time.time().minute() % 30) * 60)
        end_time = end_time.addSecs(-end_time.time().second())

        # Update the date/time widgets
        self.dateFromTimeEdit.setDateTime(start_time)
        self.dateUntilTimeEdit.setDateTime(end_time)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
